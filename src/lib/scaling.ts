/**
 * Auto-scaling module for searchgrep
 * Adapts indexing strategy based on codebase size
 */

export interface CodebaseMetrics {
  totalFiles: number;
  totalSize: number;
  avgFileSize: number;
  largeFiles: number; // Files > 50KB
  smallFiles: number; // Files < 5KB
}

export type CodebaseSize = "small" | "medium" | "large" | "massive";

export interface ScalingConfig {
  // Chunking
  chunkSize: number;
  chunkOverlap: number;
  useCodeAwareChunking: boolean;

  // Batching
  batchSize: number;
  concurrentBatches: number;

  // Embedding
  embeddingMode: "quality" | "balanced" | "fast";
  skipLowPriorityFiles: boolean;

  // Memory
  streamLargeFiles: boolean;
  largeFileThreshold: number;

  // Filtering
  autoFilterGenerated: boolean;
  autoFilterMinified: boolean;
  autoFilterVendor: boolean;
}

/**
 * Analyze codebase to determine its size category
 */
export function analyzeCodebase(
  files: { size: number; path: string }[]
): CodebaseMetrics {
  const totalFiles = files.length;
  const totalSize = files.reduce((sum, f) => sum + f.size, 0);
  const avgFileSize = totalFiles > 0 ? totalSize / totalFiles : 0;
  const largeFiles = files.filter((f) => f.size > 50 * 1024).length;
  const smallFiles = files.filter((f) => f.size < 5 * 1024).length;

  return {
    totalFiles,
    totalSize,
    avgFileSize,
    largeFiles,
    smallFiles,
  };
}

/**
 * Classify codebase size based on metrics
 */
export function classifyCodebaseSize(metrics: CodebaseMetrics): CodebaseSize {
  const { totalFiles, totalSize } = metrics;

  // Massive: 5000+ files or 100MB+
  if (totalFiles >= 5000 || totalSize >= 100 * 1024 * 1024) {
    return "massive";
  }

  // Large: 1000+ files or 20MB+
  if (totalFiles >= 1000 || totalSize >= 20 * 1024 * 1024) {
    return "large";
  }

  // Medium: 100+ files or 2MB+
  if (totalFiles >= 100 || totalSize >= 2 * 1024 * 1024) {
    return "medium";
  }

  // Small: everything else
  return "small";
}

/**
 * Get scaling configuration based on codebase size
 */
export function getScalingConfig(size: CodebaseSize): ScalingConfig {
  switch (size) {
    case "small":
      return {
        // High quality for small codebases
        chunkSize: 800,
        chunkOverlap: 200,
        useCodeAwareChunking: true,
        batchSize: 10,
        concurrentBatches: 1,
        embeddingMode: "quality",
        skipLowPriorityFiles: false,
        streamLargeFiles: false,
        largeFileThreshold: 100 * 1024,
        autoFilterGenerated: true,
        autoFilterMinified: true,
        autoFilterVendor: true,
      };

    case "medium":
      return {
        // Balanced for medium codebases
        chunkSize: 600,
        chunkOverlap: 150,
        useCodeAwareChunking: true,
        batchSize: 20,
        concurrentBatches: 2,
        embeddingMode: "balanced",
        skipLowPriorityFiles: false,
        streamLargeFiles: true,
        largeFileThreshold: 75 * 1024,
        autoFilterGenerated: true,
        autoFilterMinified: true,
        autoFilterVendor: true,
      };

    case "large":
      return {
        // Speed optimized for large codebases
        chunkSize: 500,
        chunkOverlap: 100,
        useCodeAwareChunking: true,
        batchSize: 50,
        concurrentBatches: 3,
        embeddingMode: "fast",
        skipLowPriorityFiles: true,
        streamLargeFiles: true,
        largeFileThreshold: 50 * 1024,
        autoFilterGenerated: true,
        autoFilterMinified: true,
        autoFilterVendor: true,
      };

    case "massive":
      return {
        // Maximum speed for massive codebases
        chunkSize: 400,
        chunkOverlap: 50,
        useCodeAwareChunking: false, // Too slow for massive codebases
        batchSize: 100,
        concurrentBatches: 4,
        embeddingMode: "fast",
        skipLowPriorityFiles: true,
        streamLargeFiles: true,
        largeFileThreshold: 30 * 1024,
        autoFilterGenerated: true,
        autoFilterMinified: true,
        autoFilterVendor: true,
      };
  }
}

/**
 * Patterns for detecting generated/minified/vendor code
 */
export const GENERATED_PATTERNS = [
  // Generated code markers
  /\/\/ Code generated .* DO NOT EDIT/i,
  /\/\* Generated by .*/i,
  /@generated/,
  /# This file is autogenerated/i,
  /# DO NOT EDIT/i,
  /auto-generated/i,
  /machine generated/i,

  // Lock files and generated configs
  /\.lock$/,
  /package-lock\.json$/,
  /yarn\.lock$/,
  /pnpm-lock\.yaml$/,
  /bun\.lockb$/,
  /Pipfile\.lock$/,
  /poetry\.lock$/,
  /Gemfile\.lock$/,
  /composer\.lock$/,

  // Build outputs
  /\.d\.ts$/,
  /\.d\.mts$/,
  /\.d\.cts$/,
  /\.min\.(js|css)$/,
  /\.bundle\.(js|css)$/,
  /\.chunk\.(js|css)$/,
  /\.generated\./,
  /-generated\./,

  // Source maps
  /\.map$/,
  /\.js\.map$/,
  /\.css\.map$/,
];

export const MINIFIED_PATTERNS = [
  /\.min\.(js|css)$/,
  /\.bundle\.js$/,
  /\.chunk\.js$/,
];

export const VENDOR_PATTERNS = [
  /[\/\\]vendor[\/\\]/i,
  /[\/\\]vendors[\/\\]/i,
  /[\/\\]third[_-]?party[\/\\]/i,
  /[\/\\]external[\/\\]/i,
  /[\/\\]lib[\/\\](?!src)/i, // lib/ but not lib/src
  /[\/\\]libs[\/\\]/i,
  /[\/\\]bower_components[\/\\]/i,
  /[\/\\]jspm_packages[\/\\]/i,
];

/**
 * Detect if file content appears to be minified
 * Minified files typically have very long lines with no whitespace
 */
export function isMinifiedContent(content: string): boolean {
  const lines = content.split("\n");

  // Check average line length
  const avgLineLength =
    lines.reduce((sum, line) => sum + line.length, 0) / lines.length;

  // If average line is very long (>500 chars), likely minified
  if (avgLineLength > 500) return true;

  // Check for any extremely long lines (>1000 chars)
  const hasVeryLongLines = lines.some((line) => line.length > 1000);
  if (hasVeryLongLines) return true;

  // Check whitespace ratio
  const totalChars = content.length;
  const whitespaceChars = (content.match(/\s/g) || []).length;
  const whitespaceRatio = whitespaceChars / totalChars;

  // Minified code typically has <10% whitespace
  if (whitespaceRatio < 0.1 && totalChars > 1000) return true;

  return false;
}

/**
 * Detect if file is generated code
 */
export function isGeneratedFile(path: string, content?: string): boolean {
  // Check path patterns
  for (const pattern of GENERATED_PATTERNS) {
    if (pattern.test(path)) return true;
  }

  // Check content for generation markers
  if (content) {
    const firstLines = content.slice(0, 500);
    for (const pattern of GENERATED_PATTERNS) {
      if (pattern.test(firstLines)) return true;
    }
  }

  return false;
}

/**
 * Detect if file is from vendor/third-party
 */
export function isVendorFile(path: string): boolean {
  for (const pattern of VENDOR_PATTERNS) {
    if (pattern.test(path)) return true;
  }
  return false;
}

/**
 * Detect if file is minified
 */
export function isMinifiedFile(path: string, content?: string): boolean {
  // Check path patterns
  for (const pattern of MINIFIED_PATTERNS) {
    if (pattern.test(path)) return true;
  }

  // Check content
  if (content && isMinifiedContent(content)) return true;

  return false;
}

/**
 * Calculate file priority for indexing
 * Higher priority = more important to index first
 */
export function calculateFilePriority(
  path: string,
  size: number,
  content?: string
): number {
  let priority = 50; // Base priority

  // Source files are high priority
  const sourceExtensions = [
    ".ts",
    ".tsx",
    ".js",
    ".jsx",
    ".py",
    ".go",
    ".rs",
    ".java",
    ".rb",
    ".php",
    ".cs",
    ".cpp",
    ".c",
    ".h",
    ".swift",
    ".kt",
    ".scala",
  ];
  const ext = "." + (path.split(".").pop() || "").toLowerCase();
  if (sourceExtensions.includes(ext)) priority += 20;

  // Entry points and configs are high priority
  const importantFiles = [
    "index",
    "main",
    "app",
    "server",
    "config",
    "settings",
    "routes",
    "api",
  ];
  const filename = path.split("/").pop()?.toLowerCase() || "";
  if (importantFiles.some((f) => filename.includes(f))) priority += 15;

  // Tests are medium priority
  if (
    path.includes("test") ||
    path.includes("spec") ||
    path.includes("__tests__")
  ) {
    priority -= 10;
  }

  // Large files are lower priority
  if (size > 50 * 1024) priority -= 10;
  if (size > 100 * 1024) priority -= 10;

  // Generated/vendor/minified are lowest priority
  if (isGeneratedFile(path, content)) priority -= 30;
  if (isVendorFile(path)) priority -= 25;
  if (content && isMinifiedContent(content)) priority -= 35;

  return Math.max(0, Math.min(100, priority));
}

/**
 * Filter and sort files for optimal indexing
 */
export function optimizeFileOrder(
  files: { path: string; size: number; content?: string }[],
  config: ScalingConfig
): { path: string; size: number; content?: string; priority: number }[] {
  // Calculate priorities
  const filesWithPriority = files.map((f) => ({
    ...f,
    priority: calculateFilePriority(f.path, f.size, f.content),
  }));

  // Filter based on config
  let filtered = filesWithPriority;

  if (config.autoFilterGenerated) {
    filtered = filtered.filter((f) => !isGeneratedFile(f.path, f.content));
  }

  if (config.autoFilterMinified) {
    filtered = filtered.filter(
      (f) => !isMinifiedFile(f.path, f.content)
    );
  }

  if (config.autoFilterVendor) {
    filtered = filtered.filter((f) => !isVendorFile(f.path));
  }

  // Skip low priority files in fast mode
  if (config.skipLowPriorityFiles) {
    filtered = filtered.filter((f) => f.priority >= 20);
  }

  // Sort by priority (highest first)
  filtered.sort((a, b) => b.priority - a.priority);

  return filtered;
}

/**
 * Create batches for parallel processing
 */
export function createBatches<T>(items: T[], batchSize: number): T[][] {
  const batches: T[][] = [];
  for (let i = 0; i < items.length; i += batchSize) {
    batches.push(items.slice(i, i + batchSize));
  }
  return batches;
}

/**
 * Format bytes to human readable string
 */
export function formatBytes(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  if (bytes < 1024 * 1024 * 1024)
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
}

/**
 * Get human readable codebase size description
 */
export function getCodebaseSizeDescription(
  size: CodebaseSize,
  metrics: CodebaseMetrics
): string {
  const sizeStr = formatBytes(metrics.totalSize);
  const fileCount = metrics.totalFiles;

  switch (size) {
    case "small":
      return `Small codebase (${fileCount} files, ${sizeStr}) - using high quality mode`;
    case "medium":
      return `Medium codebase (${fileCount} files, ${sizeStr}) - using balanced mode`;
    case "large":
      return `Large codebase (${fileCount} files, ${sizeStr}) - using optimized mode`;
    case "massive":
      return `Massive codebase (${fileCount} files, ${sizeStr}) - using fast mode`;
  }
}
